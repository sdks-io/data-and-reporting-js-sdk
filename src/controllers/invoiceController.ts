/**
 * Shell Data & Reporting APIsLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

import { ApiResponse, RequestOptions } from '../core';
import {
  EIDDocumentResponse,
  eIDDocumentResponseSchema,
} from '../models/eIDDocumentResponse';
import {
  EIDDownloadRequest,
  eIDDownloadRequestSchema,
} from '../models/eIDDownloadRequest';
import {
  EIDSearchRequest,
  eIDSearchRequestSchema,
} from '../models/eIDSearchRequest';
import {
  InvoiceDatesRequest,
  invoiceDatesRequestSchema,
} from '../models/invoiceDatesRequest';
import {
  InvoiceDatesResponseData,
  invoiceDatesResponseDataSchema,
} from '../models/invoiceDatesResponseData';
import {
  InvoiceDownloadRequest,
  invoiceDownloadRequestSchema,
} from '../models/invoiceDownloadRequest';
import {
  InvoiceSearchRequest,
  invoiceSearchRequestSchema,
} from '../models/invoiceSearchRequest';
import {
  InvoiceSearchResponse,
  invoiceSearchResponseSchema,
} from '../models/invoiceSearchResponse';
import {
  InvoiceSummaryRequest,
  invoiceSummaryRequestSchema,
} from '../models/invoiceSummaryRequest';
import {
  InvoiceSummaryResponse,
  invoiceSummaryResponseSchema,
} from '../models/invoiceSummaryResponse';
import {
  SearchDocumentsRequest,
  searchDocumentsRequestSchema,
} from '../models/searchDocumentsRequest';
import {
  SearchDocumentsResponse,
  searchDocumentsResponseSchema,
} from '../models/searchDocumentsResponse';
import {
  SearchStatementOfAccountRequest,
  searchStatementOfAccountRequestSchema,
} from '../models/searchStatementOfAccountRequest';
import {
  SearchStatementOfAccountResponse,
  searchStatementOfAccountResponseSchema,
} from '../models/searchStatementOfAccountResponse';
import {
  StatementOfAccountRequest,
  statementOfAccountRequestSchema,
} from '../models/statementOfAccountRequest';
import {
  StatementOfAccountResponse,
  statementOfAccountResponseSchema,
} from '../models/statementOfAccountResponse';
import { optional, string } from '../schema';
import { BaseController } from './baseController';
import { InvoiceManagementV1Dates400Error } from '../errors/invoiceManagementV1Dates400Error';
import { InvoiceManagementV1Dates401Error } from '../errors/invoiceManagementV1Dates401Error';
import { InvoiceManagementV1Dates403Error } from '../errors/invoiceManagementV1Dates403Error';
import { InvoiceManagementV1Dates404Error } from '../errors/invoiceManagementV1Dates404Error';
import { InvoiceManagementV1Dates500Error } from '../errors/invoiceManagementV1Dates500Error';
import { InvoiceManagementV1Download400Error } from '../errors/invoiceManagementV1Download400Error';
import { InvoiceManagementV1Download401Error } from '../errors/invoiceManagementV1Download401Error';
import { InvoiceManagementV1Download403Error } from '../errors/invoiceManagementV1Download403Error';
import { InvoiceManagementV1Download404Error } from '../errors/invoiceManagementV1Download404Error';
import { InvoiceManagementV1Download500Error } from '../errors/invoiceManagementV1Download500Error';
import { InvoiceManagementV1Eiddownload400Error } from '../errors/invoiceManagementV1Eiddownload400Error';
import { InvoiceManagementV1Eiddownload401Error } from '../errors/invoiceManagementV1Eiddownload401Error';
import { InvoiceManagementV1Eiddownload403Error } from '../errors/invoiceManagementV1Eiddownload403Error';
import { InvoiceManagementV1Eiddownload404Error } from '../errors/invoiceManagementV1Eiddownload404Error';
import { InvoiceManagementV1Eiddownload500Error } from '../errors/invoiceManagementV1Eiddownload500Error';
import { InvoiceManagementV1Eidsearch400Error } from '../errors/invoiceManagementV1Eidsearch400Error';
import { InvoiceManagementV1Eidsearch401Error } from '../errors/invoiceManagementV1Eidsearch401Error';
import { InvoiceManagementV1Eidsearch403Error } from '../errors/invoiceManagementV1Eidsearch403Error';
import { InvoiceManagementV1Eidsearch404Error } from '../errors/invoiceManagementV1Eidsearch404Error';
import { InvoiceManagementV1Eidsearch500Error } from '../errors/invoiceManagementV1Eidsearch500Error';
import { InvoiceManagementV1Search400Error } from '../errors/invoiceManagementV1Search400Error';
import { InvoiceManagementV1Search401Error } from '../errors/invoiceManagementV1Search401Error';
import { InvoiceManagementV1Search403Error } from '../errors/invoiceManagementV1Search403Error';
import { InvoiceManagementV1Search404Error } from '../errors/invoiceManagementV1Search404Error';
import { InvoiceManagementV1Search500Error } from '../errors/invoiceManagementV1Search500Error';
import { InvoiceManagementV1Searchdocuments400Error } from '../errors/invoiceManagementV1Searchdocuments400Error';
import { InvoiceManagementV1Searchdocuments401Error } from '../errors/invoiceManagementV1Searchdocuments401Error';
import { InvoiceManagementV1Searchdocuments403Error } from '../errors/invoiceManagementV1Searchdocuments403Error';
import { InvoiceManagementV1Searchdocuments404Error } from '../errors/invoiceManagementV1Searchdocuments404Error';
import { InvoiceManagementV1Searchdocuments500Error } from '../errors/invoiceManagementV1Searchdocuments500Error';
import { InvoiceManagementV1Searchstatementofaccount400Error } from '../errors/invoiceManagementV1Searchstatementofaccount400Error';
import { InvoiceManagementV1Searchstatementofaccount401Error } from '../errors/invoiceManagementV1Searchstatementofaccount401Error';
import { InvoiceManagementV1Searchstatementofaccount403Error } from '../errors/invoiceManagementV1Searchstatementofaccount403Error';
import { InvoiceManagementV1Searchstatementofaccount404Error } from '../errors/invoiceManagementV1Searchstatementofaccount404Error';
import { InvoiceManagementV1Searchstatementofaccount500Error } from '../errors/invoiceManagementV1Searchstatementofaccount500Error';
import { InvoiceManagementV1Statementofaccount400Error } from '../errors/invoiceManagementV1Statementofaccount400Error';
import { InvoiceManagementV1Statementofaccount401Error } from '../errors/invoiceManagementV1Statementofaccount401Error';
import { InvoiceManagementV1Statementofaccount403Error } from '../errors/invoiceManagementV1Statementofaccount403Error';
import { InvoiceManagementV1Statementofaccount404Error } from '../errors/invoiceManagementV1Statementofaccount404Error';
import { InvoiceManagementV1Statementofaccount500Error } from '../errors/invoiceManagementV1Statementofaccount500Error';
import { InvoiceManagementV1Summary400Error } from '../errors/invoiceManagementV1Summary400Error';
import { InvoiceManagementV1Summary401Error } from '../errors/invoiceManagementV1Summary401Error';
import { InvoiceManagementV1Summary403Error } from '../errors/invoiceManagementV1Summary403Error';
import { InvoiceManagementV1Summary404Error } from '../errors/invoiceManagementV1Summary404Error';
import { InvoiceManagementV1Summary500Error } from '../errors/invoiceManagementV1Summary500Error';

export class InvoiceController extends BaseController {
  /**
   * This API allows to search invoice data in the Shell Card Platform. It provides flexible search
   * criteria in the request body and supports paging.
   *
   *
   *
   * This API will also query the relevant invoice documents list and return a reference number that can
   * be used to download invoice documents (PDF and Proofing elements in a zip file).
   *
   *
   *
   * #### Supported operations
   *
   * * Search invoices by account
   *
   * * Search invoices by invoice type or invoice status
   *
   * * Search invoices by invoice id or number
   *
   * * Search invoices by invoiced country
   *
   * * Search invoices including einvoices
   *
   * * Search invoices by summary document
   *
   * * Search invoices by statement of account
   *
   * * Search invoices by fixed and custom date periods
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards) for requests
   *                                                    and responses. This will be played back in the response from
   *                                                    the request.
   * @param body         Invoice Search RequestBody
   * @return Response from the API call
   */
  async invoiceSearch(
    requestId: string,
    body?: InvoiceSearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<InvoiceSearchResponse>> {
    const req = this.createRequest('POST', '/invoice-management/v1/search');
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(invoiceSearchRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Search400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Search401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(403, InvoiceManagementV1Search403Error, 'Forbidden');
    req.throwOn(
      404,
      InvoiceManagementV1Search404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Search500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsJson(invoiceSearchResponseSchema, requestOptions);
  }

  /**
   * This API returns the high level summary of invoices that match the  given search criteria. The same
   * search criteria as the endpoint `/v1/invoice/search` is supported with the exception of paging
   * related parameters.
   *
   *
   *
   *
   *
   * #### Supported operations
   *
   * * Search invoices by account
   *
   * * Search invoices by invoice type or invoice status
   *
   * * Search invoices by invoice id or number
   *
   * * Search invoices by invoiced country
   *
   * * Search invoices including einvoices
   *
   * * Search invoices by summary document
   *
   * * Search invoices by statement of account
   *
   * * Search invoices by fixed and custom date periods
   *
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards) for requests
   *                                                     and responses. This will be played back in the response from
   *                                                     the request.
   * @param body         Invoice Search RequestBody
   * @return Response from the API call
   */
  async invoiceSummary(
    requestId: string,
    body?: InvoiceSummaryRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<InvoiceSummaryResponse>> {
    const req = this.createRequest('POST', '/invoice-management/v1/summary');
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(invoiceSummaryRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Summary400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Summary401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(403, InvoiceManagementV1Summary403Error, 'Forbidden');
    req.throwOn(
      404,
      InvoiceManagementV1Summary404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Summary500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsJson(invoiceSummaryResponseSchema, requestOptions);
  }

  /**
   * This API allows querying the details of the latest statement of account (SOA) generated for a given
   * Payer.
   *
   *
   *
   * The endpoint supports querying SOA documents by various input parameters specified in the request
   * body.
   *
   *
   *
   * #### Supported operations
   *
   * * Search invoice SOA by payer and account
   *
   * * Search invoice SOA including monthly trend (last 13 months invocie trend summary)
   *
   * * Search invoice SOA including past SOAs
   *
   * * Search invoice SOA including due/overdue documents
   *
   * * Search invoice SOA including invoice summary
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards) for
   *                                                         requests and responses. This will be played back in the
   *                                                         response from the request.
   * @param body         StatementOfAccount RequestBody
   * @return Response from the API call
   */
  async statementOfAccount(
    requestId: string,
    body?: StatementOfAccountRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<StatementOfAccountResponse>> {
    const req = this.createRequest(
      'POST',
      '/invoice-management/v1/statementofaccount'
    );
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(statementOfAccountRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Statementofaccount400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Statementofaccount401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(
      403,
      InvoiceManagementV1Statementofaccount403Error,
      'Forbidden'
    );
    req.throwOn(
      404,
      InvoiceManagementV1Statementofaccount404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Statementofaccount500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsJson(statementOfAccountResponseSchema, requestOptions);
  }

  /**
   * - This API will return the list of Invoice Dates and Numbers for the given date range. If the dates
   * are not provided then it will fetch the data for past 13 months.
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards) for requests
   *                                                   and responses. This will be played back in the response from the
   *                                                   request.
   * @param body         StatementOfAccount RequestBody
   * @return Response from the API call
   */
  async dates(
    requestId: string,
    body?: InvoiceDatesRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<InvoiceDatesResponseData>> {
    const req = this.createRequest('POST', '/invoice-management/v1/dates');
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(invoiceDatesRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Dates400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Dates401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(403, InvoiceManagementV1Dates403Error, 'Forbidden');
    req.throwOn(
      404,
      InvoiceManagementV1Dates404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Dates500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsJson(invoiceDatesResponseDataSchema, requestOptions);
  }

  /**
   * - This API will allow querying of SOA from different systems
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards)
   *                                                               for requests and responses. This will be played back
   *                                                               in the response from the request.
   * @param body         searchstatementofaccount RequestBody
   * @return Response from the API call
   */
  async searchStatementOfAccount(
    requestId: string,
    body?: SearchStatementOfAccountRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SearchStatementOfAccountResponse>> {
    const req = this.createRequest(
      'POST',
      '/invoice-management/v1/searchstatementofaccount'
    );
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(searchStatementOfAccountRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Searchstatementofaccount400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Searchstatementofaccount401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(
      403,
      InvoiceManagementV1Searchstatementofaccount403Error,
      'Forbidden'
    );
    req.throwOn(
      404,
      InvoiceManagementV1Searchstatementofaccount404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Searchstatementofaccount500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsJson(
      searchStatementOfAccountResponseSchema,
      requestOptions
    );
  }

  /**
   * - This API allows querying the details of all invoices successfully uploaded to the Worldline
   * invoice repository and file reference numbers for downloading.
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards) for
   *                                                      requests and responses. This will be played back in the
   *                                                      response from the request.
   * @param body         SearchDocuments RequestBody
   * @return Response from the API call
   */
  async searchDocuments(
    requestId: string,
    body?: SearchDocumentsRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<SearchDocumentsResponse>> {
    const req = this.createRequest(
      'POST',
      '/invoice-management/v1/searchdocuments'
    );
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(searchDocumentsRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Searchdocuments400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Searchdocuments401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(403, InvoiceManagementV1Searchdocuments403Error, 'Forbidden');
    req.throwOn(
      404,
      InvoiceManagementV1Searchdocuments404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Searchdocuments500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsJson(searchDocumentsResponseSchema, requestOptions);
  }

  /**
   * - This API provides the functionality needed for the screen “EID FILES” in the web interface. It
   * allows retrieving a list of EIDs based on search criteria.
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards) for requests and
   *                                                responses. This will be played back in the response from the
   *                                                request.
   * @param body         EIDSearch RequestBody
   * @return Response from the API call
   */
  async eidSearch(
    requestId: string,
    body?: EIDSearchRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<EIDDocumentResponse>> {
    const req = this.createRequest('POST', '/invoice-management/v1/eidsearch');
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(eIDSearchRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Eidsearch400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Eidsearch401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(403, InvoiceManagementV1Eidsearch403Error, 'Forbidden');
    req.throwOn(
      404,
      InvoiceManagementV1Eidsearch404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Eidsearch500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsJson(eIDDocumentResponseSchema, requestOptions);
  }

  /**
   * - This API downloads Invoice Documents i.e., ZIP file with Invoice PDF file and Proofing Elements in
   * XML format from invoice repository.
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards) for
   *                                                      requests and responses. This will be played back in the
   *                                                      response from the request.
   * @param body         Invoice Download RequestBody
   * @return Response from the API call
   */
  async download(
    requestId: string,
    body?: InvoiceDownloadRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NodeJS.ReadableStream | Blob>> {
    const req = this.createRequest('POST', '/invoice-management/v1/download');
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(invoiceDownloadRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Download400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Download401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(403, InvoiceManagementV1Download403Error, 'Forbidden');
    req.throwOn(
      404,
      InvoiceManagementV1Download404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Download500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsStream(requestOptions);
  }

  /**
   * - This service allows downloading one or more EID documents and the corresponding signature material
   * (where applicable) in one single request
   *
   * - The number of EID that can be downloaded at once is limited to 100 documents.
   *
   *
   *
   * @param requestId    Mandatory UUID (according to RFC 4122 standards) for requests
   *                                                  and responses. This will be played back in the response from the
   *                                                  request.
   * @param body         EIDInvoice Download RequestBody
   * @return Response from the API call
   */
  async eidDownload(
    requestId: string,
    body?: EIDDownloadRequest,
    requestOptions?: RequestOptions
  ): Promise<ApiResponse<NodeJS.ReadableStream | Blob>> {
    const req = this.createRequest(
      'POST',
      '/invoice-management/v1/eiddownload'
    );
    const mapped = req.prepareArgs({
      requestId: [requestId, string()],
      body: [body, optional(eIDDownloadRequestSchema)],
    });
    req.header('RequestId', mapped.requestId);
    req.header('Content-Type', 'application/json');
    req.json(mapped.body);
    req.throwOn(
      400,
      InvoiceManagementV1Eiddownload400Error,
      'The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).'
    );
    req.throwOn(
      401,
      InvoiceManagementV1Eiddownload401Error,
      'The request has not been applied because it lacks valid  authentication credentials for the target resource.'
    );
    req.throwOn(403, InvoiceManagementV1Eiddownload403Error, 'Forbidden');
    req.throwOn(
      404,
      InvoiceManagementV1Eiddownload404Error,
      'The origin server did not find a current representation  for the target resource or is not willing to disclose  that one exists.'
    );
    req.throwOn(
      500,
      InvoiceManagementV1Eiddownload500Error,
      'The server encountered an unexpected condition that  prevented it from fulfilling the request.'
    );
    req.authenticate([{ bearerToken: true }]);
    return req.callAsStream(requestOptions);
  }
}
